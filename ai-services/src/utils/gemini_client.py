"""
Gemini AI client wrapper for CogniLearn AI Services
"""
import asyncio
import json
import logging
from typing import Dict, Any, List, Optional, Union
import google.generativeai as genai
from google.generativeai.types import HarmCategory, HarmBlockThreshold

from ..config import get_gemini_config

logger = logging.getLogger(__name__)


class GeminiClient:
    """Async wrapper for Google Gemini API."""
    
    def __init__(self, api_key: Optional[str] = None):
        """Initialize Gemini client."""
        config = get_gemini_config()
        self.api_key = api_key or config["api_key"]
        self.model_name = config["model"]
        self.max_tokens = config["max_tokens"]
        self.temperature = config["temperature"]
        self.top_p = config["top_p"]
        
        if not self.api_key:
            raise ValueError("Gemini API key is required")
        
        # Configure Gemini
        genai.configure(api_key=self.api_key)
        
        # Initialize model
        self.model = genai.GenerativeModel(
            model_name=self.model_name,
            safety_settings={
                HarmCategory.HARM_CATEGORY_HARASSMENT: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
                HarmCategory.HARM_CATEGORY_HATE_SPEECH: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
                HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
                HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE,
            }
        )
        
        logger.info(f"Gemini client initialized with model: {self.model_name}")
    
    async def generate_text(
        self,
        prompt: str,
        temperature: Optional[float] = None,
        max_tokens: Optional[int] = None,
        top_p: Optional[float] = None,
        system_instruction: Optional[str] = None
    ) -> str:
        """Generate text using Gemini."""
        try:
            # Prepare generation config
            generation_config = genai.types.GenerationConfig(
                temperature=temperature or self.temperature,
                max_output_tokens=max_tokens or self.max_tokens,
                top_p=top_p or self.top_p,
            )
            
            # Add system instruction if provided
            full_prompt = prompt
            if system_instruction:
                full_prompt = f"System: {system_instruction}\n\nUser: {prompt}"
            
            # Generate content
            response = await asyncio.to_thread(
                self.model.generate_content,
                full_prompt,
                generation_config=generation_config
            )
            
            if response.candidates and response.candidates[0].content.parts:
                return response.candidates[0].content.parts[0].text
            else:
                logger.warning("No content generated by Gemini")
                return ""
                
        except Exception as e:
            logger.error(f"Gemini text generation error: {e}")
            raise
    
    async def generate_json(
        self,
        prompt: str,
        schema: Optional[Dict[str, Any]] = None,
        temperature: Optional[float] = None,
        max_tokens: Optional[int] = None
    ) -> Dict[str, Any]:
        """Generate JSON response using Gemini."""
        try:
            # Add JSON formatting instruction
            json_prompt = f"""{prompt}

Please respond with valid JSON only. Do not include any markdown formatting, explanations, or additional text.
{f"Follow this schema: {json.dumps(schema, indent=2)}" if schema else ""}

Response:"""
            
            response_text = await self.generate_text(
                json_prompt,
                temperature=temperature or 0.3,  # Lower temperature for JSON
                max_tokens=max_tokens
            )
            
            # Clean and parse JSON
            cleaned_text = self._clean_json_response(response_text)
            
            try:
                return json.loads(cleaned_text)
            except json.JSONDecodeError as e:
                logger.warning(f"Failed to parse JSON response: {e}")
                logger.debug(f"Raw response: {response_text}")
                
                # Try to extract JSON from response
                extracted_json = self._extract_json_from_text(response_text)
                if extracted_json:
                    return extracted_json
                
                # Return fallback structure
                return {"error": "Failed to parse JSON response", "raw_response": response_text}
                
        except Exception as e:
            logger.error(f"Gemini JSON generation error: {e}")
            return {"error": str(e)}
    
    async def generate_list(
        self,
        prompt: str,
        item_count: Optional[int] = None,
        temperature: Optional[float] = None
    ) -> List[str]:
        """Generate a list of items using Gemini."""
        try:
            list_prompt = f"""{prompt}

Please respond with a JSON array of strings.
{f"Generate exactly {item_count} items." if item_count else ""}

Format: ["item1", "item2", "item3", ...]

Response:"""
            
            response = await self.generate_json(list_prompt, temperature=temperature)
            
            if isinstance(response, list):
                return response
            elif isinstance(response, dict) and "items" in response:
                return response["items"]
            else:
                logger.warning("Unexpected list response format")
                return []
                
        except Exception as e:
            logger.error(f"Gemini list generation error: {e}")
            return []
    
    def _clean_json_response(self, text: str) -> str:
        """Clean JSON response text."""
        # Remove markdown formatting
        text = text.replace("```json", "").replace("```", "")
        
        # Remove common prefixes
        text = text.replace("Response:", "").replace("JSON:", "")
        
        # Strip whitespace
        text = text.strip()
        
        return text
    
    def _extract_json_from_text(self, text: str) -> Optional[Dict[str, Any]]:
        """Extract JSON object from text."""
        try:
            # Find JSON object boundaries
            start_idx = text.find('{')
            if start_idx == -1:
                start_idx = text.find('[')
            
            if start_idx == -1:
                return None
            
            # Find matching closing bracket
            bracket_count = 0
            end_idx = start_idx
            opening_char = text[start_idx]
            closing_char = '}' if opening_char == '{' else ']'
            
            for i in range(start_idx, len(text)):
                if text[i] == opening_char:
                    bracket_count += 1
                elif text[i] == closing_char:
                    bracket_count -= 1
                    if bracket_count == 0:
                        end_idx = i
                        break
            
            if bracket_count == 0:
                json_text = text[start_idx:end_idx + 1]
                return json.loads(json_text)
            
        except Exception as e:
            logger.debug(f"JSON extraction failed: {e}")
        
        return None
    
    async def check_health(self) -> bool:
        """Check if Gemini API is accessible."""
        try:
            response = await self.generate_text("Hello", max_tokens=10)
            return bool(response.strip())
        except Exception as e:
            logger.error(f"Gemini health check failed: {e}")
            return False


# Global client instance
_gemini_client: Optional[GeminiClient] = None


def get_gemini_client() -> GeminiClient:
    """Get or create Gemini client instance."""
    global _gemini_client
    if _gemini_client is None:
        _gemini_client = GeminiClient()
    return _gemini_client


async def initialize_gemini(api_key: Optional[str] = None) -> bool:
    """Initialize Gemini client and test connection."""
    global _gemini_client
    try:
        _gemini_client = GeminiClient(api_key)
        health_check = await _gemini_client.check_health()
        if health_check:
            logger.info("Gemini client initialized successfully")
        else:
            logger.warning("Gemini client initialized but health check failed")
        return health_check
    except Exception as e:
        logger.error(f"Failed to initialize Gemini client: {e}")
        return False
